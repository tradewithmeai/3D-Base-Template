<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Component Catalog Test - Phase 2A</title>
    <style>
        body { 
            margin: 0; 
            padding: 0;
            font-family: 'Courier New', monospace; 
            background: #1a1a1a;
            color: #00ff00;
            overflow-x: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
        }
        .canvas-area {
            flex: 1;
            position: relative;
        }
        .test-panel {
            width: 450px;
            background: rgba(0, 0, 0, 0.9);
            border-left: 2px solid #00ff00;
            padding: 20px;
            overflow-y: auto;
        }
        .header {
            text-align: center;
            border-bottom: 2px solid #00ff00;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        .test-section {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        .btn {
            background: #333;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 6px 12px;
            margin: 3px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            display: inline-block;
            min-width: 80px;
        }
        .btn:hover {
            background: #00ff00;
            color: #000;
        }
        .btn.danger {
            border-color: #ff0000;
            color: #ff0000;
        }
        .btn.danger:hover {
            background: #ff0000;
            color: #fff;
        }
        .btn.warning {
            border-color: #ffff00;
            color: #ffff00;
        }
        .btn.warning:hover {
            background: #ffff00;
            color: #000;
        }
        .test-results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }
        .test-result {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            text-align: center;
            font-size: 10px;
        }
        .test-result.pass {
            border-color: #00ff00;
            color: #00ff00;
        }
        .test-result.fail {
            border-color: #ff0000;
            color: #ff0000;
        }
        .test-result.pending {
            border-color: #ffff00;
            color: #ffff00;
        }
        .console-mini {
            background: #000;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            font-size: 9px;
            white-space: pre-wrap;
        }
        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            font-size: 10px;
        }
        .stat-item {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 3px;
            text-align: center;
        }
        h3 { margin: 0 0 10px 0; color: #00ff00; font-size: 14px; }
        h4 { margin: 5px 0; color: #00ff00; font-size: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-area" id="canvas-container">
            <!-- Three.js canvas will be inserted here -->
        </div>
        
        <div class="test-panel">
            <div class="header">
                <h3>üß™ COMPONENT CATALOG TEST</h3>
                <p>Phase 2A: Semantic Data & Remove/Add Cycle</p>
            </div>

            <div class="test-section">
                <h4>üìã Registry Tests</h4>
                <button class="btn" onclick="testLoadRegistry()">Load Registry</button>
                <button class="btn" onclick="testComponentDefinitions()">Test Definitions</button>
                <button class="btn" onclick="testSemanticData()">Test Semantic Data</button>
                <button class="btn" onclick="testColorPalettes()">Test Palettes</button>
            </div>

            <div class="test-section">
                <h4>üèóÔ∏è Component Creation</h4>
                <button class="btn" onclick="createTestComponents()">Create All Components</button>
                <button class="btn" onclick="testUserDataRoundTrip()">Test UserData</button>
                <button class="btn" onclick="validateSceneIntegrity()">Validate Scene</button>
            </div>

            <div class="test-section">
                <h4>üóëÔ∏è Remove/Add Cycle</h4>
                <button class="btn warning" onclick="testSingleRemoveAdd()">Single Remove/Add</button>
                <button class="btn warning" onclick="testFullSceneCycle()">Full Scene Cycle</button>
                <button class="btn danger" onclick="testMemoryCleanup()">Memory Cleanup</button>
            </div>

            <div class="test-section">
                <h4>üé® Property Changes</h4>
                <button class="btn" onclick="testColorChanges()">Test Colors</button>
                <button class="btn" onclick="testMaterialChanges()">Test Materials</button>
                <button class="btn" onclick="testVisibilityChanges()">Test Visibility</button>
            </div>

            <div class="test-section">
                <h4>üöÄ Comprehensive Tests</h4>
                <button class="btn" onclick="runAllTests()">üß™ Run All Tests</button>
                <button class="btn" onclick="runStressTest()">‚ö° Stress Test</button>
                <button class="btn danger" onclick="clearScene()">üóëÔ∏è Clear Scene</button>
            </div>

            <div class="test-results" id="test-results">
                <div class="test-result pending" id="registry-test">
                    <div>Registry</div>
                    <div>üü° Pending</div>
                </div>
                <div class="test-result pending" id="creation-test">
                    <div>Creation</div>
                    <div>üü° Pending</div>
                </div>
                <div class="test-result pending" id="semantic-test">
                    <div>Semantic</div>
                    <div>üü° Pending</div>
                </div>
                <div class="test-result pending" id="remove-add-test">
                    <div>Remove/Add</div>
                    <div>üü° Pending</div>
                </div>
                <div class="test-result pending" id="memory-test">
                    <div>Memory</div>
                    <div>üü° Pending</div>
                </div>
                <div class="test-result pending" id="properties-test">
                    <div>Properties</div>
                    <div>üü° Pending</div>
                </div>
            </div>

            <div class="stats" id="stats">
                <div class="stat-item">
                    <div>Objects Created</div>
                    <div id="created-count">0</div>
                </div>
                <div class="stat-item">
                    <div>Objects Active</div>
                    <div id="active-count">0</div>
                </div>
                <div class="stat-item">
                    <div>Memory Disposed</div>
                    <div id="disposed-count">0</div>
                </div>
                <div class="stat-item">
                    <div>Scene Objects</div>
                    <div id="scene-count">0</div>
                </div>
            </div>

            <div class="console-mini" id="console-output">
                <div>üß™ Component Catalog Test Console</div>
                <div>Ready to test bulletproof component system...</div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="logging-framework.js"></script>
    <script src="component-manager.js"></script>
    <script>
        // Test environment setup
        let scene, camera, renderer;
        let testComponents = [];
        
        // Capture console output
        const originalLog = console.log;
        const consoleOutput = document.getElementById('console-output');
        
        console.log = function(...args) {
            originalLog.apply(console, args);
            const message = args.join(' ');
            consoleOutput.innerHTML += '\n' + message;
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        };

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(25, 10, 25);
            camera.lookAt(20, 4, 15);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth - 450, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Add basic lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 15, 10);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
                updateStats();
            }
            animate();
            
            console.log('üé¨ Three.js scene initialized');
        }

        function updateTestResult(testId, passed, message = '') {
            const element = document.getElementById(testId);
            element.className = `test-result ${passed ? 'pass' : 'fail'}`;
            element.innerHTML = `
                <div>${testId.replace('-test', '').toUpperCase()}</div>
                <div>${passed ? '‚úÖ PASS' : '‚ùå FAIL'}</div>
                ${message ? `<div style="font-size: 8px; margin-top: 3px;">${message}</div>` : ''}
            `;
        }

        function updateStats() {
            const stats = window.ComponentManager.getMemoryStats();
            document.getElementById('created-count').textContent = stats.created;
            document.getElementById('active-count').textContent = stats.active;
            document.getElementById('disposed-count').textContent = stats.disposed;
            document.getElementById('scene-count').textContent = scene.children.filter(obj => obj.userData.componentType).length;
        }

        async function testLoadRegistry() {
            console.log('\nüß™ Testing registry loading...');
            
            const success = await window.ComponentManager.loadRegistry();
            const registry = window.ComponentManager.registry;
            
            const hasComponents = registry && registry.components && Object.keys(registry.components).length > 0;
            const hasPalettes = registry && registry.colorPalettes && Object.keys(registry.colorPalettes).length > 0;
            const hasRooms = registry && registry.rooms && Object.keys(registry.rooms).length > 0;
            
            const allPassed = success && hasComponents && hasPalettes && hasRooms;
            updateTestResult('registry-test', allPassed, 
                `${Object.keys(registry?.components || {}).length} components loaded`);
            
            return allPassed;
        }

        function testComponentDefinitions() {
            console.log('\nüß™ Testing component definitions...');
            
            const registry = window.ComponentManager.registry;
            if (!registry) {
                updateTestResult('registry-test', false, 'Registry not loaded');
                return false;
            }
            
            const componentTypes = Object.keys(registry.components);
            let allValid = true;
            
            componentTypes.forEach(type => {
                const def = registry.components[type];
                const hasModel = def.model && ['box', 'plane', 'cylinder', 'sphere'].includes(def.model);
                const hasSize = def.size && Array.isArray(def.size);
                const hasMaterial = def.material && def.material.color;
                const hasSemanticId = def.semanticId;
                
                if (!hasModel || !hasSize || !hasMaterial || !hasSemanticId) {
                    console.error(`‚ùå Invalid definition for ${type}`);
                    allValid = false;
                }
            });
            
            updateTestResult('registry-test', allValid, `${componentTypes.length} definitions validated`);
            return allValid;
        }

        function testSemanticData() {
            console.log('\nüß™ Testing semantic data structure...');
            
            const registry = window.ComponentManager.registry;
            const components = registry.components;
            let semanticValid = true;
            
            Object.keys(components).forEach(type => {
                const def = components[type];
                const hasSemanticId = def.semanticId;
                const hasSemanticName = def.semanticName;
                const hasCategory = def.category;
                const hasAgentEditable = def.agentEditable;
                
                if (!hasSemanticId || !hasSemanticName || !hasCategory || !hasAgentEditable) {
                    console.error(`‚ùå Missing semantic data for ${type}`);
                    semanticValid = false;
                }
            });
            
            updateTestResult('semantic-test', semanticValid, 'All semantic data present');
            return semanticValid;
        }

        function testColorPalettes() {
            console.log('\nüß™ Testing color palettes...');
            
            const registry = window.ComponentManager.registry;
            const palettes = registry.colorPalettes;
            let palettesValid = true;
            
            Object.keys(palettes).forEach(paletteName => {
                const palette = palettes[paletteName];
                if (!palette.colors || !Array.isArray(palette.colors) || palette.colors.length === 0) {
                    console.error(`‚ùå Invalid palette: ${paletteName}`);
                    palettesValid = false;
                }
            });
            
            updateTestResult('registry-test', palettesValid, 
                `${Object.keys(palettes).length} palettes validated`);
            return palettesValid;
        }

        async function createTestComponents() {
            console.log('\nüß™ Creating test components...');
            
            if (!window.ComponentManager.registry) {
                await testLoadRegistry();
            }
            
            const testConfigs = [
                { type: 'referencePole', position: [0, 0.5, 0] },
                { type: 'lobbyFloor', position: [20, 0, 15], rotation: [-Math.PI/2, 0, 0] },
                { type: 'lobbyNorthWall', position: [20, 4, 30], name: 'northWall' },
                { type: 'lobbySouthWall', position: [20, 4, 0], name: 'southWall' },
                { type: 'debugBall', position: [35, 1.5, 15] }
            ];
            
            testComponents = [];
            let creationSuccess = true;
            
            for (const config of testConfigs) {
                const mesh = createComponent(config.type, config, scene);
                if (mesh) {
                    testComponents.push(mesh);
                } else {
                    creationSuccess = false;
                }
            }
            
            updateTestResult('creation-test', creationSuccess, 
                `${testComponents.length}/${testConfigs.length} created`);
            return creationSuccess;
        }

        function testUserDataRoundTrip() {
            console.log('\nüß™ Testing userData round-trip...');
            
            let userDataValid = true;
            
            testComponents.forEach(mesh => {
                const userData = mesh.userData;
                const hasComponentType = userData.componentType;
                const hasSemanticId = userData.semanticId;
                const hasUniqueId = userData.uniqueId;
                const hasAgentEditable = userData.agentEditable;
                
                if (!hasComponentType || !hasSemanticId || !hasUniqueId || !hasAgentEditable) {
                    console.error(`‚ùå Invalid userData for ${userData.componentType}`);
                    userDataValid = false;
                }
            });
            
            updateTestResult('semantic-test', userDataValid, 'UserData intact');
            return userDataValid;
        }

        function validateSceneIntegrity() {
            console.log('\nüß™ Validating scene integrity...');
            
            const results = window.ComponentManager.validateSceneIntegrity(testComponents.length);
            const allPassed = results.every(result => result.passed);
            
            updateTestResult('memory-test', allPassed, 
                `${results.filter(r => r.passed).length}/${results.length} checks passed`);
            return allPassed;
        }

        function testSingleRemoveAdd() {
            console.log('\nüß™ Testing single remove/add cycle...');
            
            if (testComponents.length === 0) {
                console.error('‚ùå No test components available');
                return false;
            }
            
            const testMesh = testComponents[0];
            const originalData = {
                componentType: testMesh.userData.componentType,
                position: testMesh.position.toArray(),
                rotation: testMesh.rotation.toArray()
            };
            
            // Remove component
            const removeSuccess = removeComponent(testMesh, scene);
            
            // Recreate component
            const newMesh = createComponent(originalData.componentType, {
                position: originalData.position,
                rotation: originalData.rotation
            }, scene);
            
            if (newMesh) {
                testComponents[0] = newMesh;
            }
            
            const cycleSuccess = removeSuccess && newMesh !== null;
            updateTestResult('remove-add-test', cycleSuccess, 'Single cycle completed');
            return cycleSuccess;
        }

        function testFullSceneCycle() {
            console.log('\nüß™ Testing full scene remove/add cycle...');
            
            // Store original data
            const originalData = testComponents.map(mesh => ({
                componentType: mesh.userData.componentType,
                position: mesh.position.toArray(),
                rotation: mesh.rotation.toArray(),
                name: mesh.userData.name
            }));
            
            // Remove all components
            let removeCount = 0;
            testComponents.forEach(mesh => {
                if (removeComponent(mesh, scene)) {
                    removeCount++;
                }
            });
            
            // Clear array
            testComponents = [];
            
            // Recreate all components
            let createCount = 0;
            originalData.forEach(data => {
                const mesh = createComponent(data.componentType, {
                    position: data.position,
                    rotation: data.rotation,
                    name: data.name
                }, scene);
                
                if (mesh) {
                    testComponents.push(mesh);
                    createCount++;
                }
            });
            
            const fullCycleSuccess = removeCount === originalData.length && 
                                   createCount === originalData.length;
            
            updateTestResult('remove-add-test', fullCycleSuccess, 
                `${removeCount}/${originalData.length} removed, ${createCount}/${originalData.length} recreated`);
            return fullCycleSuccess;
        }

        function testMemoryCleanup() {
            console.log('\nüß™ Testing memory cleanup...');
            
            const initialStats = window.ComponentManager.getMemoryStats();
            logMemory('BEFORE_CLEANUP');
            
            // Create and immediately remove components to test cleanup
            for (let i = 0; i < 10; i++) {
                const mesh = createComponent('debugBall', { position: [i, 1, i] }, scene);
                if (mesh) {
                    removeComponent(mesh, scene);
                }
            }
            
            const finalStats = window.ComponentManager.getMemoryStats();
            logMemory('AFTER_CLEANUP');
            
            const memoryCleanupSuccess = finalStats.disposed >= initialStats.disposed + 10;
            updateTestResult('memory-test', memoryCleanupSuccess, 
                `+${finalStats.disposed - initialStats.disposed} disposed`);
            return memoryCleanupSuccess;
        }

        function testColorChanges() {
            console.log('\nüß™ Testing color changes...');
            
            if (testComponents.length === 0) {
                console.error('‚ùå No test components available');
                return false;
            }
            
            const testMesh = testComponents.find(m => m.userData.agentEditable?.color);
            if (!testMesh) {
                console.error('‚ùå No color-editable components found');
                return false;
            }
            
            const success = updateComponentProperty(testMesh, 'color', '#ff0000');
            updateTestResult('properties-test', success, 'Color change successful');
            return success;
        }

        function testMaterialChanges() {
            console.log('\nüß™ Testing material property changes...');
            
            const testMesh = testComponents.find(m => m.userData.agentEditable?.roughness);
            if (!testMesh) {
                console.error('‚ùå No material-editable components found');
                return false;
            }
            
            const success1 = updateComponentProperty(testMesh, 'roughness', 0.1);
            const success2 = updateComponentProperty(testMesh, 'metalness', 0.8);
            
            const allSuccess = success1 && success2;
            updateTestResult('properties-test', allSuccess, 'Material changes successful');
            return allSuccess;
        }

        function testVisibilityChanges() {
            console.log('\nüß™ Testing visibility changes...');
            
            const testMesh = testComponents.find(m => m.userData.agentEditable?.visibility);
            if (!testMesh) {
                console.error('‚ùå No visibility-editable components found');
                return false;
            }
            
            const success1 = updateComponentProperty(testMesh, 'visibility', false);
            const success2 = updateComponentProperty(testMesh, 'visibility', true);
            
            const allSuccess = success1 && success2;
            updateTestResult('properties-test', allSuccess, 'Visibility changes successful');
            return allSuccess;
        }

        async function runAllTests() {
            console.log('\nüöÄ RUNNING ALL COMPONENT CATALOG TESTS...\n');
            
            const startTime = performance.now();
            
            const results = [];
            results.push(await testLoadRegistry());
            results.push(testComponentDefinitions());
            results.push(testSemanticData());
            results.push(testColorPalettes());
            results.push(await createTestComponents());
            results.push(testUserDataRoundTrip());
            results.push(validateSceneIntegrity());
            results.push(testSingleRemoveAdd());
            results.push(testFullSceneCycle());
            results.push(testMemoryCleanup());
            results.push(testColorChanges());
            results.push(testMaterialChanges());
            results.push(testVisibilityChanges());
            
            const duration = performance.now() - startTime;
            const passed = results.filter(r => r).length;
            const total = results.length;
            
            console.log(`\n‚úÖ COMPONENT CATALOG TESTS COMPLETED in ${duration.toFixed(2)}ms`);
            console.log(`üìä RESULTS: ${passed}/${total} tests passed`);
            
            return passed === total;
        }

        function runStressTest() {
            console.log('\n‚ö° Running component stress test...');
            
            const startTime = performance.now();
            
            // Create many components rapidly
            for (let i = 0; i < 50; i++) {
                const mesh = createComponent('debugBall', { 
                    position: [Math.random() * 40, 1, Math.random() * 30] 
                }, scene);
                
                if (mesh) {
                    removeComponent(mesh, scene);
                }
            }
            
            const duration = performance.now() - startTime;
            logPerf('Stress Test Duration', duration, 2000);
            
            console.log(`‚ö° STRESS TEST COMPLETED: ${duration.toFixed(2)}ms for 100 operations`);
        }

        function clearScene() {
            console.log('\nüóëÔ∏è Clearing scene...');
            
            testComponents.forEach(mesh => {
                removeComponent(mesh, scene);
            });
            
            testComponents = [];
            console.log('üóëÔ∏è Scene cleared');
        }

        // Initialize everything
        initScene();
        console.log('üß™ COMPONENT CATALOG TEST READY');
        console.log('Click "Run All Tests" to validate bulletproof component system...');
    </script>
</body>
</html>